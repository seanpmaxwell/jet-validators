# jet-validators ✈️

[![npm](https://img.shields.io/npm/v/jet-validators?label=npm&color=0ea5e9)](https://www.npmjs.com/package/jet-validators)
[![downloads](https://img.shields.io/npm/dm/jet-validators?label=downloads&color=38bdf8)](https://www.npmjs.com/package/jet-validators)
[![types](https://img.shields.io/npm/types/jet-validators?label=types&color=22c55e)](https://www.npmjs.com/package/jet-validators)
[![bundle size](https://img.shields.io/bundlephobia/minzip/jet-validators?label=bundle&color=0f172a)](https://bundlephobia.com/package/jet-validators)
[![license](https://img.shields.io/npm/l/jet-validators?label=license&color=334155)](LICENSE)

> A comprehensive collection of TypeScript validator functions and utilities for common compile and runtime checks.

jet-validator's `parseObject` function is one of the fastest schema validation tools out there not requiring a compilation step. Check out these benchmarks <a href="#benchmarks">here</a>.

## Table of Contents

* [Introduction](#introduction)
* [Benchmarks](#benchmarks)
* [Installation](#installation)
* [Basic Validators](#basic-validators)
* [Complex Validators](#complex-validators)
* [Utilities](#utilities)
* [Object Schema Validation](#object-schema-validation)
* [Safety Modes](#safety-modes)
<br/>

## Introduction <a name="introduction"></a>

`jet-validators` is a large collection of small, composable validator functions commonly used when validating values in TypeScript.

* Drop-in validators you can import and use immediately
* Covers the vast majority of real-world validation needs
* Extremely fast and lightweight object schema validation
* Tiny: bundle + zip size only **4.7kb**
* **Zero dependencies**

### Quick Glance

```ts
import { isOptionalString } from 'jet-validators';

if (isOptionalString(value)) {
  // value is string | undefined
}
```
<br/>

## Benchmarks <a name="benchmarks"></a>

These results are generated by running `npm run build` inside `./benchmarks`, which executes `benchmarks/run-benchmarks.ts` to compare `parseObject` to popular schema validators.

- Generated: 2026-01-01T17:09:33.398Z
- Node.js: v24.11.0
- Dataset size: 1000
- Iterations per library: 100000

| Library | Iterations | Total Time (ms) | Ops/Second |
| --- | ---: | ---: | ---: |
| jet-validators | 100,000 | 95.96 | 1,042,147.57 |
| Zod | 100,000 | 163.24 | 612,592.7 |
| Joi | 100,000 | 1,269.13 | 78,794.36 |
| Yup | 100,000 | 2,510.4 | 39,834.32 |
| Valibot | 100,000 | 280.1 | 357,020.58 |
<br/>


## Installation <a name="installation"></a>

```bash
npm install jet-validators
```

<br/>

## Basic Validators <a name="basic-validators"></a>

Basic validators can be imported directly and used without configuration.

All validators follow consistent naming patterns:

* `isX`
* `isOptionalX`
* `isNullableX`
* `isNullishX`
* `isXArray` (and variants)

### Nullables

* `isUndef`
* `isNull`
* `isNullish` (`null | undefined`)

---

### `isBoolean`

* `isBoolean`
* `isOptionalBoolean`
* `isNullableBoolean`
* `isNullishBoolean`
* `isBooleanArray` (+ variants)

---

### `isValidBoolean`

Valid after running through [parseBoolean](#parse-boolean)

* `isValidBoolean`
* `isOptionalValidBoolean`
* `isNullableValidBoolean`
* `isNullishValidBoolean`
* `isValidBooleanArray` (+ variants)

---

### `isNumber`

* `isNumber` (+ optional / nullable / array variants)

Sub-categories:

* **Positive**
* **Negative**
* **Unsigned**

Each includes the full optional / nullable / array variants.

---

### `isInteger`

Same structure as `isNumber`, including:

* Positive
* Negative
* Unsigned

---

### `isBigInt`

* `isBigInt`
* `isOptionalBigInt`
* `isNullableBigInt`
* `isNullishBigInt`
* `isBigIntArray` (+ variants)

---

### `isValidNumber`

Valid after numeric coercion.

* `isValidNumber`
* `isOptionalValidNumber`
* `isNullableValidNumber`
* `isNullishValidNumber`
* `isValidNumberArray` (+ variants)

---

### `isString`

* `isString` (+ optional / nullable / array variants)

---

### `isNonEmptyString`

Ensures `.length > 0`.

* `isNonEmptyString` (+ variants)

---

### `isSymbol`

* `isSymbol` (+ variants)

---

### `isDate`

Checks for a `Date` instance with a valid timestamp.

```ts
!isNaN(date.getTime())
```

* `isDate` (+ variants)

---

### `isValidDate`

Accepts `Date`, `string`, or `number` and validates via `new Date(...)`.

* `isValidDate` (+ variants)

---

### `isObject`

Is non-nullable object

* `isObject` (+ variants)


### `isPlainObject`

Is it an object of type `Record<string, unknown>` and nothing else (i.e. `Date`, `Array`, `etc`).

* `isPlainObject` (+ variants)

---

### `isFunction`

* `isFunction` (+ variants)

<br/>

## Complex Validators <a name="complex-validators"></a>

These require an initialization step and return a validator function.

---

### `isInArray`

```ts
const isAllowed = isInArray(['a', 'b', 'c']);
isAllowed('a'); // true
```

Supports optional / nullable variants.

---

### `isInRange`

Checks whether a number (or numeric string) falls within a range.

Rules:

* `(min, max)` → exclusive
* `[min], [max]` → inclusive
* `[]` → no bound
* Reverse bounds → “outside range”

```ts
const between0and100 = isInRange([0], [100]);
between0and100(50);   // true
between0and100('100'); // true
```

```ts
const negative = isInRange([], 0);
negative(-1); // true
```

```ts
const outside = isInRange(100, 50);
outside(101); // true
outside(75);  // false
```

---

### `isKeyOf`

Checks whether a value is a key of an object.

```ts
const obj = { foo: 'bar', baz: 'qux' } as const;
const isKey = isKeyOf(obj);

isKey('foo'); // true
```

> Note: Does not support symbol keys.

---

### `isValueOf`

Checks whether a value exists in an object.

```ts
const obj = { foo: 'bar', baz: 'qux' } as const;
const isValue = isValueOf(obj);

isValue('bar'); // true
```

Includes the `ValueOf<T>` utility type.

<br/>

## Utilities <a name="utilities"></a>

Utilities are imported from:

```ts
import { parseObject } from 'jet-validators/utils';
```

---

### `nonNullable`

Removes `null` and `undefined` from a validator.

```ts
const isStrictString = nonNullable(isNullishString);
```

---

### `makeOptional / makeNullable / makeNullish`

Wrap custom validators to extend their accepted types.

```ts
const isEmail = (arg: unknown): arg is TEmail =>
  isString(arg) && EMAIL_REGEX.test(arg);

const isNullishEmail = makeNullish(isEmail);
```

---

### `transform`

Transforms a value before validation.

```ts
const isParsedArray = transform(JSON.parse, isNumberArray);
// isParsedArray is (arg: unknown, (transformedValue: number[]) => void): arg is number[]
```

Supports callbacks for accessing transformed values.

---

### `parseBoolean` <a name="parse-boolean"></a>

Converts common boolean representations to actual booleans:

* `"true"`, `"false"` (case-insensitive)
* `"1"`, `"0"`
* `1`, `0`

```ts
parseBoolean('TrUe'); // true
parseBoolean(0);      // false
```

---

### `parseJson`

Safely wraps `JSON.parse`.

```ts
const nums = parseJson<number[]>('[1,2,3]');
```

Throws if input is not a string.

<br/>

## Object Schema Validation <a name="object-schema-validation"></a>

Lightweight schema validation for objects using validator functions.

> These utilities are intentionally simpler than libraries like Zod or AJV.

---

### `parseObject`

* If valid, returns a full deep clone of the provided object; otherwise returns `false`.
* Removes unknown keys (by default)
* Can enforce strict type-safety on schemas with generics
* Can infer types from non-generic schemas.
* Optional error callback

```ts
const parseUser = parseObject<IUser>({
  id: transform(Number, isNumber),
  name: isString,
});
```

Supports:

* optional / nullable
* arrays
* nested schemas
* loose / strict modes

---

### Error handling

You can pass a callback as the second argument to the `parseObject` function or the function returned from it which will provide an array of errors if there are any. Each error object has the format:

| Field           | Type        | Description |
|-----------------|------------|-------------|
| `info`          | `string`   | General information about the validation failure. |
| `functionName`  | `string`   | Name of the validator function that failed. |
| `value`         | `unknown`  | The value that caused the validation failure (optional). |
| `caught`        | `string`   | Error message caught from an unsafe validator function, if any. |
| `key`           | `string`   | The key at which the failure occurred but only when it happened at the root level.|
| `keyPath`       | `string[]` | Full path to the failing value for anything other than a key at the rror level. If the failure occurs while inside an array variant (e.g. `parseObjectArray`), the first element represents the array index of the failing item. |

#### Example

```ts
const parseUsersArrray = parseObjectArray({ name: isString });
const parseUsersArrray([{name: 'sean'}, {name: 123 }], (errors) => ...);

// Errors callback param above will be:
[{
  info: "Validator function returned false.",
  functionName: "isString",
  value: 123,
  keyPath: ["1", "name"]
}]
```

---

### `testObject`

Same behavior as `parseObject`, but returns a **type predicate**.

```ts
if (testUser(user)) {
  // user is IUser
}
```

---

### Combining parse + test

Nested schemas may use `testObject` inside `parseObject`, with caveats around TypeScript inference. Supplying generics restores full type safety. Note you cannot use `parseObject` on a nested schema because it returns the object being tested not a type-predicate:
```ts

  interface IUser {
    id: number;
    name: string;
    address: {
      street: string;
      city: string;
    };
    country?: {
      name: string;
      code: number;
    };
  }

  const parseUser = parseObject<IUser>({
    id: isUnsignedInteger,
    name: isString,

    // **testObject implied** address cannot be undefined
    // and type safety will allow extra keys
    address: {
      street: isString,
      city: isString,
    },

    // **testObject explicit** undefined allowed with the optional option and
    // strict type-safety is being enforced
    country: testOptionalObject<IUser['country']>({
      abbreviation: isString,
      name: isString,
    }),
  });
```

---

### Wrapping parse/test

You may want to wrap a `parseObject` to let's say, make sure all parse functions throw the same custom Error object. When wrapping these utilities, ensure your generics extend `Schema<T>` to preserve type safety.

> Please see the section [Wrapping with Custom Validators around schemas](./test/utils/parseObject.test.ts#L857) for a full example.

---

### Adding Custom Validators to schemas

Any function of the form `(arg: unknown) => arg is T` can be used in schemas. If your custom validator checks an object and has nested errors and you want those errors to bubble up to the highest level, you to need to make sure to provide a callback. Other wise parseObject will only see the custom validator itself as the failing function and any nested errors will be ignored. 

> Please see the section [Adding Custom Validators to schemas](./test/utils/parseObject.test.ts#L798) for a full example.

---

### Manually creating error arrays

If you want to setup your own error array you need to use the `setIsParseErrorArray` function to mark it as such because in the real world there could be validator functions with callbacks for reasons other than error handling:

> Please see the section [Manually creating error arrays](./test/utils/parseObject.test.ts#L886) for a full example.

---

### Getting the type for a "parse/test"Object function

If you need the type for a parse function you created, simply use the utility type `ReturnType` and pass the `typeof "whichever parse function your using"` with a generic.

> Please see the unit-test [Test setting a type for the parseObject](./test/utils/parseObject.test.ts#L693) for a full example.

---

## Safety Modes <a name="safety-modes"></a>

Control how extra object properties are handled. Nested schemas inherit the parent mode unless overridden:

* **loose** – keep extra keys
* **default** – remove extra keys (no error)
* **strict** – remove extra keys and emit errors

```ts
const strictUser = strictParseObject({
  address: { street: isString }, // Will inherit strict from parent
  country: looseTestObject(...), // is being overridden
});
```
